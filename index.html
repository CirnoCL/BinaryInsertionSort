<!DOCTYPE html>
  <html>
    <head>
      <!--Import materialize.css-->
      <link type="text/css" rel="stylesheet" href="css/materialize.min.css"  media="screen,projection"/>
      
      <link type="text/css" rel="stylesheet" href="css/test.css">
      
      <!--Let browser know website is optimized for mobile-->
      <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>-->
        
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    </head>
    <meta charset="utf-8" /> 
    <body>
        <div class="intro red darken-4 z-depth-1">
            <h1 class="grey-text text-lighten-5">Insercion Binaria</h1>
            <h5 class="grey lighten-4 grey-text text-darken-1">Algoritmos y Estructuras de Datos</h5>
        </div>
        
        <div class="container about">
            <div class="row">
                <div class="col s12 m12 14">
                    <div class="card green-grey darken-1">
                        <div class="card-content  black-text" style="text-align: justify">
                        <h5>Busqueda Binaria</h5>
                        <div>
                             Es un método que se basa en la división sucesiva del espacio ocupado por el vector en sucesivas mitades, hasta encontrar el elemento buscado.
 
                        Esta búsqueda utiliza un método de “divide y vencerás” para localizar el valor deseado. Con este método se examina primero el elemento central de la lista; si este es el elemento buscado entonces la búsqueda ha terminado. En caso contrario se determina si el elemento buscado está en la primera o segunda mitad de la lista y a continuación se repite el proceso anterior, utilizando el elemento central de esta sublista.
                            Este tipo de búsqueda se utiliza en vectores ordenados.
                        <br>
                        <br>
                        Este algoritmo reduce el tiempo de búsqueda considerablemente, ya que disminuye exponencialmente el número de iteraciones necesarias.

                        Está altamente recomendado para buscar en arrays de gran tamaño. Por ejemplo, en uno conteniendo 50.000.000 elementos, realiza como máximo 26 comparaciones (en el peor de los casos).
                        </div>
                        <hr>
                        <div>
                             <ul class="collection with-header">
                                <li class="collection-header"><h5>Ejemplo</h5></li>
                                <li class="collection-item">Dado el siguiente conjunto de de 9 datos ordenados en orden ascendente, encuentra el valor 8 (el cual lo denominaremos como nuestra llave):<br>
                                [1 2 3 4 5 6 7 8 9]<br></li>
                                <li class="collection-item">El primer paso es encontrar el punto medio(al ser 9 elementos, el punto medio seria (9+1)/2 lo cual seria el 5to elemento):<br>
                                [1 2 3 4 <b>5</b> 6 7 8 9]<br></li>
                                <li class="collection-item">El siguiente paso es comparar la llave con el 5, son iguales? obvio no, es 8 menor que 5? nope, es 8 mayor que 5? aye. Ahora sabemos que el elemento a encontrar se encuentra en la segunda parte del arreglo (si es que existe), por lo que ahora nos quedamos con:<br>
                                [6 7 8 9]<br></li>
                                <li class="collection-item">Se vuelve a calcular el punto medio (4+1)/2=2.5, si nos queda un resultado con decimal solo es necesario redondear el valor de cualquier manera, siguiendo la matematica de los enteros simplemente truncaremos el .5 y nuestro nuevo punto medio sera el 2do elemento:<br>
                                [6 <b>7</b> 8 9]<br>
                                <li class="collection-item">Es 7 igual a 8? nope, es 8 menor que 7? nope, es 8 mayor que 7? si. Por lo que el valor que necesitamos se encuentra en la segunda parte del arreglo y nos quedamos con:<br>
                                [8 9]<br>
                            <br></li>
                                <li class="collection-item">Volvemos a encontrar el punto medio (2+1)/2:<br>
                                [<b>8</b> 9]<br></li>
                                <li class="collection-item">  Es 8 igual a 8? sep, y con esto encontramos el elemento a buscar.</li>
                            </ul>
                        </div>
                        <hr>
                        <div class="container portfolio">
                        <div class="row">
                            <div class="col s12 m12 l12 portfolio-holder">
                                <h5>Pseudocodigo</h5>
                                <img class="materialboxed" src="img/bbpseudo.png">
                                <hr>
                                <h5>Busqueda Binaria en C</h5>
                                <img class="materialboxed" src="img/bbcode.png">
                                <hr>
                                <h5>Busqueda Binaria Recursiva en C</h5>
                                <img class="materialboxed" src="img/bbrecursive.png">
                            </div>
                        </div>
                        </div>

                    </div>
                        
                </div>
                <div class="card green-grey darken-1">
                    <div class="card-content  black-text" style="text-align: justify">
                        <h5>Insercion Binaria</h5>
                        El metodó por inserción binaria es una mejora del método de inserción directa. La mejora consiste en realizar una busqueda binaria en lugar de una búsqueda secuencial, para insertar un elemento en la parte izquierda del arreglo, que ya se encuentra ordenado.

El proceso al igual que el de Inserción Directa, se repite desde el 2do hasta el n-ésimo elemento.
Toma su nombre debido a la similitud de ordenamiento de los arboles binarios.<br>
                    <ul class="collection with-header">
                        <li class="collection-header"><h5>Tengamos en cuenta que:</h5></li>
                        <li class="collection-item">La secuencia donde se inserta el nuevo elemento ya esta ordenada.</li>
                        <li class="collection-item">Búsqueda Binaria para localizar el lugar de inserción.</li>
                        <li class="collection-item">Desplazar elementos.</li>
                        <li class="collection-item">Insertar elemento.</li>
                        <li class="collection-item">    Toma su nombre debido a la similitud de ordenamiento de los arboles binarios.</li>
                    </ul>
                    <br>
                    <div>
                        <h5>Analisis del algoritmo</h5>
                        <ul class="collection with-header">
                            <li class="collection-item">En el mejor de los casos, el array estará inicialmente ordenado: F(N) = Ω(N)</li>
                            <li class="collection-item">En el peor de los casos, el array está inversamente ordenado: F(N) = O(N^2)</li>
                            <li class="collection-item">En el caso medio, tanto en el número de comparaciones como en el número de asignaciones es de orden cuadrático: F(N) = θ(N^2)</li>
                        </ul>
                    </div>
                    <br>
                    <div class="container portfolio">
                        <div class="row">
                            <div class="col s12 m12 l12 portfolio-holder">
                                        <h5>Pseudocodigo</h5>
                                        <img class="materialboxed" src="img/bipseudo.png">
                                        <hr>
                                        <h5>Insercion Binaria en C</h5>
                                        <img class="materialboxed" src="img/binarysort.png">
                            </div>
                        </div>
                    </div>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <footer>
          <div class="footer-copyright">
            <div class="container">
            © 2014 Copyright Text
            <a class="grey-text text-lighten-4 right" href="#!">Link</a>
            </div>
          </div>
        </footer>
      <!--Import jQuery before materialize.js-->
      <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
      <script type="text/javascript" src="js/materialize.min.js"></script>
      <script type="text/javascript" src="js/test.js"></script>
    </body>
  </html>